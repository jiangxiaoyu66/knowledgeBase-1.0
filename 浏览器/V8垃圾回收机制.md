# 垃圾回收

参考：

[聊聊V8引擎的垃圾回收](https://juejin.cn/post/6844903591510016007)

## 为什么要有垃圾回收

在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过**malloc**函数去手动分配，在用完之后，还要时刻记得用**free**函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。

但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。

不需要我们去手动管理内存了，所以自然要有**垃圾回收**，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。

垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。



## 新生代，老生代

v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

### 新生代

新生代被分为 From 和 To 两个空间。处于使用状态的semispace称为**From空间**，处于闲置状态的semispace称为**To空间**。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。

#### Scavenge 算法

Scavenge 算法分为三步：

1. 首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

2. 如果对象不存活，则释放对象的空间。

3. 最后将 From 空间和 To 空间角色进行交换。

### 老生代

#### 老生代的条件

新生代对象晋升到老生代有两个条件：

- 第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

- 第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。



#### 老生代的两个算法

老生代采用了标记清除法和标记压缩法。

##### 标记清除

标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。

由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。

##### 标记压缩

整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

![image-20210309105908175](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/image-20210309105908175.png)

由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。



参考：

[V8垃圾回收GC](https://libin1991.github.io/2019/11/19/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC/)









