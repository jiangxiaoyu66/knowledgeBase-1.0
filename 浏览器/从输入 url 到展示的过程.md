[浏览器输入url到显示的过程阐述？](https://github.com/ljianshu/Blog/issues/24)

[从输入 URL 到页面展示发生了什么？](https://juejin.cn/post/6931635435852529677#heading-31)

- 读取浏览器缓存
- DNS 解析
- TCP 三次握手
- 发送请求，分析 url，设置请求报文(头，主体)
- 服务器返回请求的文件 (html)
- 浏览器渲染
  - HTML parser --> DOM Tree
    - 标记化算法，进行元素状态的标记
    - dom 树构建
  - CSS parser --> Style Tree
    - 解析 css 代码，生成样式树
  - attachment --> Render Tree
    - 结合 dom树 与 style树，生成渲染树
  - layout: 布局
  - GPU painting: 像素绘制页面



# 网络请求

1.  浏览器缓存
2. DNS 解析
3. TCP 三次握手

## 一. 浏览器缓存

参考：[缓存（二）——浏览器缓存机制：强缓存、协商缓存](https://github.com/amandakelake/blog/issues/41#)#41

### 一、概述

良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度
通常浏览器缓存策略分为两种：强缓存和协商缓存

#### 1、基本原理

- 1）浏览器在加载资源时，根据请求头的`expires`和`cache-control`判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
- 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
- 3）如果前面两者都没有命中，直接从服务器加载资源

##### 网络请求整体流程图

![38223505-d8ab53da-371d-11e8-9263-79814b6971a5](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png)

#### 2、相同点

如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

#### 3、不同点

强缓存不发请求到服务器，协商缓存会发请求到服务器。

### 二、强缓存

强缓存通过`Expires`和`Cache-Control`两种响应头实现

#### 1、Expires

Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

```
Expires: Wed, 11 May 2018 07:20:00 GMT
```

#### 2、Cache-Control

Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间

```
Cache-Control: max-age=315360000
```



### 三、协商缓存

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对Header来管理的

#### 1、Last-Modified，If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag

#### 2、ETag、If-None-Match

`Etag`就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

`ETag`的优先级比`Last-Modified`更高

##### 为什么要用`ETag`？

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器不能精确的得到文件的最后修改时间。

总而言之，如果是last-modified，s级别内的修改不能被察觉，或者某一些服务器返回的修改时间不准确；要么就是文件内容未改，只是修改时间发生改变，也被检测出修改了

### 四、几种状态码的区别

- `200`：强缓Expires/Cache-Control存失效时，返回新的资源文件
- `200(from cache)`: 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功
- `304(Not Modified )`：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304





## 二. DNS 解析

参考： [史上最详细的经典面试题 从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072)

### 是什么

DNS解析实际上就是寻找你所需要的资源的过程。

假设你输入`www.baidu.com`，而这个网址并不是百度的真实地址，互联网中每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，所以就需要一个网址和IP地址的转换，也就是DNS解析。

### 解析过程

DNS解析其实是一个递归的过程

输入`www.google.com`网址后，首先在本地的域名服务器中查找，没找到去根域名服务器查找，没有再去`com`顶级域名服务器查找，如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用。

大致过程就是`.`-> .com ->`google.com.` -> `www.google.com.`。 (你可能觉得我多写 .，并木有，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上)

顺序：本地域名=> 根域名=> com顶级域名 => ......

![16a634c9285cb545](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/16a634c9285cb545.png)



### DNS负载均衡

不知道你们有没有注意这样一件事，你访问`baidu.com`的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡

## 三. TCP三次握手

#### 前置知识

tcp标志位有6种标志：

SYN(synchronous建立联机) 

ACK(acknowledgement 确认) 

PSH(push传送) 

FIN(finish结束)

RST(reset重置) 

URG(urgent紧急)



而对应SYN和ACK的分别是Sequence number(顺序号码) 和Acknowledge number(确认号码)

#### TCP三次握手


第一次握手：客户端发送位码syn=1，随机产生seq number=1234567。服务端由syn=1知道，客户端要求建立连接。

第二次握手：服务端在收到syn=1后知道客户端请求连接，所以向客户端发送ack=1，syn=1，ack number=(1234567+1), 随机的seq number=(123456) 的包

第三次握手：客户端检查ack number是否正确（即第一次发送的seq number+1），ack是否为1。

​	若正确，客户端再次发送ack=1，ack number=（123456+1）。服务端收到后确认ack和ack number，正确则建立连接成功

参考文章：[TCP三次握手中SYN，ACK，Seq三者的关系](https://blog.csdn.net/u014507230/article/details/45310847)



**为什么是3次握手，不是2次握手？**

**2次握手只能确认客户端的发送功能和服务器的接收功能没有问题；但是不能保证客户端的接收功能和服务端的发送功能是否正常。**

>参考：[**TCP.md**](https://github.com/ChellyAI/note/blob/master/HTTP/3%E3%80%81TCP.md)
>
> 这是为了确认在即将建立连接时，两端都处于准备建立连接的状态，防止失效的连接请求报文被服务器接收而产生错误。**通过三次握手，能够让双方都知道彼此的接收能力、发送能力没问题**。
>
>  假设客户端发送请求连接报文A，因为网络原因超时，此时TCP启动超时重传机制，再次发送连接请求报文B，顺利到达服务端并建立连接。结束连接后，服务端又收到报文A，此时若不同客户端确认，直接进入**ESTABLISHED**状态并发送同意连接报文至客户端，而客户端已经处于**CLOSED**状态，因此连接不会建立且服务端一直处于等待状态，造成资源浪费。
>
>  举个例子，两个人发微信聊天，如果A对B说“听得到吗”，B回复A“听得到”，正常情况下这两次交流就可以确认并开始互发消息。但假如第一次A问“听得到吗”的时候在隧道内，导致消息并未及时发出去，而A就把微信关闭了，当B接收到A后回复一句“听得到”并做好准备聊天，导致空等。而如果A收到B的回复后再回一句“好的好的，咱开始吧”，让B知道A现在也准备好了，加一道保险，更加安全。

**为什么不是四次？**

因为三次已经足够确认双方的发送和接收的能力了，四次以及四次以上当然就没必要啦

**三次握手过程中可以携带数据吗？**

可以，但是只有第三次，此时的`established`状态相对安全并且够确认服务器的接收发送能力。

而不能在第一次握手携带数据是为了防止黑客在`syn`中放入大量数据造成服务器资源的消耗。



#### TCP四次挥手

参考：[面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-6)

1. 客户端发送一个 FIN 报文，报文中会指定一个顺序号码。此时客户端处于 `FIN_WAIT1` 状态。 

   即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务端的确认。

2. 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 

   即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

   

3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 

   即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

4. 第三次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 

   即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

> 注意了，这个时候，客户端需要等待两个 `MSL`(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 `ACK `成功到达，挥手结束。否则客户端重发 ACK。

![16da9fd28b49f652](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/16da9fd28b49f652.png)

**为什么要等待 2 MSL?**

参考：[为什么TCP4次挥手时等待为2MSL？](https://www.zhihu.com/question/67013338)

当客户端发送ACK=1的报文后，客户端不知道服务端是否真的接收到自己的ACK，所以对于客户端来说：

（1）如果服务端没有收到自己的ACK，服务端自己会超时重传FiN

那么客户端再次接到重传的FIN，会再次发送ACK

（2）如果服务端收到了自己的ACK，也不会再发任何消息，包括ACK

无论是(1)还是(2)，客户端都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：

去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

这恰恰就是**2MSL( Maximum Segment Life)。**

**为什么是四次挥手而不是三次？**

- 因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。
- 因此先发一个ACK表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。 `如果是三次挥手会有什么问题？` 等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

















































