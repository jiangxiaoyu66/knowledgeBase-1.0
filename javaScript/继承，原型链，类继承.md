原型和原型链

- prototype和__proto__
- 执行上下文栈、变量对象、作用域链、this
- 执行上下文
- 闭包
  - 变量提升
  - v8垃圾回收
- call、apply、bind原理及实现
- 创建对象和继承
- oop编程思想





## 一. 原型和原型链

### 1. 什么是原型？

为了解决构造函数创建对象时，**共有属性被重复声明**的问题，出现了原型的概念。

- 每个函数都有原型prototype，每个对象都有\_proto\_。每个对象的_proto_指向其构造函数的prototype。
- 每一个对象或者函数都会从原型"继承"属性



### 2. 什么是原型链？

**每个对象的_proto_指向其构造函数的prototype。**这种链条式关系叫作原型链

**原型链的机制：**

当对象寻找某一属性时，如果自身属性没有就**沿着原型链上依次往上找**，直到一个对象的原型对象为null（null没有原型）。这个就叫原型链

 

原型是一个对象，那原型的原型也是对象，顺着找下去关系就如下所示，蓝色的线即为原型链：

![image-20210131171842953](https://i.loli.net/2021/01/31/7T8wiup5M9BHsKG.png)



----------------------------



## 二. 执行上下文栈、变量对象、作用域链、this





















------------







## 继承

继承有几种方式，思路是什么，如何实现？尝试手写

可参考：

[ES5实现继承的那些事](https://juejin.cn/post/6844903872847151112#comment)

[JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16#)#16

[继承的实现](https://juejin.cn/post/6844904136161361933#heading-22)

[【面试系列】JS实现继承的几种方式](https://juejin.cn/post/6847902217190506509#heading-2)



1.借助call实现继承

```js
  function Parent1(){
    this.name = 'parent1';
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  console.log(new Child1);
```

问题：

子类只能继承非原型上的属性和原型上除函数以外的属性

> 父类原型上的方法子类是无法继承和访问的，但是父类中的非原型方法子类还是能够继承的

第二种方式借助原型链实现继承：

```js
  function Parent2() {
    this.name = 'parent2';
    this.play = [1, 2, 3]
  }
  function Child2() {
    this.type = 'child2';
  }
  Child2.prototype = new Parent2();

  console.log(new Child2());
```


问题：

两个实例使用的是同一个原型对象。

```js
  var s1 = new Child2();
  var s2 = new Child2();
  s1.play.push(4);
  console.log(s1.play, s2.play); // [1,2,3,4]  [1,2,3,4]
```

上面代码只改变了s1的play属性，s2也变了。因为两个实例使用的是同一个原型。

第三种方式：将前两种组合：

```js
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
```

问题：


```js
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play); // [1,2,3,4]  [1,2,3]
```

解决了原型共享的问题，但是父类构造函数多执行了一次

优化方案1：

```js
  function Parent4 () {
    this.name = 'parent4';
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = 'child4';
  }
  Child4.prototype = Parent4.prototype;
```

问题：

```js
  var s3 = new Child4();
  var s4 = new Child4();
  console.log(s3)
```

![image-20210119104327855](https://i.loli.net/2021/01/19/4uzbcvkZTQYKULr.png)

子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。

优化方案2：

```js
  function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = 'child5';
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;

```

Object.create()

方法创建一个新对象，使用现有的对象来提供新创建的对象的**proto**。





## `class / extend`: 类声明与继承

es6加入的class其实是为了开发者方便创建类，与其他语言在写法上尽量一致，但是js原生并没有类这个东西，为了实现类的效果，可以通过js的构造器来实现，class使用new关键字生成实例，构造器也是通过new来实例化，那么可以推断class本质也是个构造器
