## 介绍下重绘和回流(Repaint & Reflow)， 以及如何进行优化?

### 重绘

render tree中的元素更新属性，且属性不影响布局，只影响样式的。如改变颜色和大小

### 回流

render tree中的元素，他们的布局或者几何属性发生改变，会触发回流

### 如何优化？

#### JS

1.最小化重绘和重排

- **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。

2.批量修改DOM

- **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。

避免触发同步布局事件

- **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。

##### 避免触发同步布局事件

当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。

举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：

```js
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}
```

这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。**每一次循环都会强制浏览器刷新队列**。我们可以优化为:

```js
const width = box.offsetWidth;
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}
```



#### css

**从回流重绘角度**

1.**CSS3 硬件加速（GPU加速）**

使用transform，opacity，filters，will-change，触发CSS3硬件加速，避免回流重绘

2.**对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

**从综合性能角度**

1.**避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

2.**尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

3.**避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

4.**避免使用`CSS`表达式**，可能会引发回流。

解释：CSS 表达式致命的一点是，它执行的频率远远超出了你的想象。理想情况是，我们希望这个表达式在页面加载或刷新的时候执行。事与愿违，只要页面一滚动，它就会重复执行，甚至鼠标移动的时候，它也会执行。
　　要知道80% 的用户喜欢使用鼠标在页面上移动，来帮助他们阅读或者根本就是漫无目的的移动。那就可以想象当用户阅读文章的时候，鼠标的移动量会有多大。因为CSS 表达式在鼠标移动的时候就会执行，所以光看这一个页面，CSS 表达式就执行上千遍，甚至上万遍。这对于用户体验来说简直就是灾难。



参考文章：[**介绍下重绘和回流（Repaint & Reflow），以及如何进行优化**](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)

