# 网络层
参考:[「计算机网络」前端必备知识，看到就是赚到系列（上）](https://juejin.cn/post/6915362842212302862#heading-27)

## 传输层（TCP和UDP）
### TCP和UDP的区别
- TCP是**面向连接的、可靠的、基于字节流**的传输层协议
- UDP是一个**面向无连接**的传输层协议

**详细区别：**

1.
    tcp基于连接，所以可靠性高；但也正因为如此，需要**三次握手**，重新确认等连接过程，所以实时性差，有延迟；

    udp基于无连接，所以可靠性低；但是因为没有连接的过程，所以实时性强

2.
    tcp连接只能是**一对一**的；udp支持一对一，一对多，多对多的交互通信
3.
    udp**传输数据容量**比tcp大

    在传输相同大小的数据时，tcp首部开销20字节；udp首部开销只有8个字节，tcp报头比udp复杂，故实际包含的用户数据较少。

4.
    TCP在IP协议的基础上添加了**序号机制、确认机制、超时重传机制**等，保证了传输的可靠性，不会出现丢包或乱序。所以TCP性能开销比较大。
    

    而UDP没有相关机制保证数据完整性，所以可能因为网络会有丢包现象，另外因为不管相关机制，所以性能消耗比TCP小得多

应用场景的区别：
    在不追求数据完整性的时候使用TCP；在追求实时性时候使用UDP


### TCP
TCP三大核心：

1. 面向连接；所谓面向连接，指的是客户端与服务端的连接，在双方互相通信之前，TCP需要三次握手简历连接，而UDP没有相应的简历连接的过程

2. 可靠性；TCP可靠性主要体现在

   **有状态**：TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错

   **可控制**：意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发

3. 面向字节流；UDP数据传输基于数据报，仅仅是继承了IP层的特性，而TCP为维护状态，将IP包变成了字节流

#### TCP三次握手

tcp标志位有6种标志：

SYN(synchronous建立联机) 

ACK(acknowledgement 确认) 

PSH(push传送) 

FIN(finish结束)

RST(reset重置) 

URG(urgent紧急)



而对应SYN和ACK的分别是Sequence number(顺序号码) 和Acknowledge number(确认号码)

--------



第一次握手：客户端发送位码syn=1，随机产生seq number=1234567。服务端由syn=1知道，客户端要求建立连接。

第二次握手：服务端在收到syn=1后知道客户端请求连接，所以向客户端发送ack=1，syn=1，ack number=(1234567+1), 随机的seq number=(123456) 的包

第三次握手：客户端检查ack number是否正确（即第一次发送的seq number+1），ack是否为1。

若正确，客户端再次发送ack=1，ack number=（123456+1）。服务端收到后确认ack和ack number，正确则建立连接成功

参考文章：[TCP三次握手中SYN，ACK，Seq三者的关系](https://blog.csdn.net/u014507230/article/details/45310847)



**为什么是3次握手，不是2次握手？**

**2次握手只能确认客户端的发送功能和服务器的接收功能没有问题；但是不能保证客户端的接收功能和服务端的发送功能是否正常。**

>参考：[**TCP.md**](https://github.com/ChellyAI/note/blob/master/HTTP/3%E3%80%81TCP.md)
>
> 这是为了确认在即将建立连接时，两端都处于准备建立连接的状态，防止失效的连接请求报文被服务器接收而产生错误。**通过三次握手，能够让双方都知道彼此的接收能力、发送能力没问题**。
>
>  假设客户端发送请求连接报文A，因为网络原因超时，此时TCP启动超时重传机制，再次发送连接请求报文B，顺利到达服务端并建立连接。结束连接后，服务端又收到报文A，此时若不同客户端确认，直接进入**ESTABLISHED**状态并发送同意连接报文至客户端，而客户端已经处于**CLOSED**状态，因此连接不会建立且服务端一直处于等待状态，造成资源浪费。
>
>  举个例子，两个人发微信聊天，如果A对B说“听得到吗”，B回复A“听得到”，正常情况下这两次交流就可以确认并开始互发消息。但假如第一次A问“听得到吗”的时候在隧道内，导致消息并未及时发出去，而A就把微信关闭了，当B接收到A后回复一句“听得到”并做好准备聊天，导致空等。而如果A收到B的回复后再回一句“好的好的，咱开始吧”，让B知道A现在也准备好了，加一道保险，更加安全。

**为什么不是四次？**

因为三次已经足够确认双方的发送和接收的能力了，四次以及四次以上当然就没必要啦

**三次握手过程中可以携带数据吗？**

可以，但是只有第三次，此时的`established`状态相对安全并且够确认服务器的接收发送能力。

而不能在第一次握手携带数据是为了防止黑客在`syn`中放入大量数据造成服务器资源的消耗。



#### TCP四次挥手

参考：[面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-6)

1. 客户端发送一个 FIN 报文，报文中会指定一个顺序号码。此时客户端处于 `FIN_WAIT1` 状态。 

   即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务端的确认。

2. 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 

   即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

   

3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 

   即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

4. 第三次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 

   即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

> 注意了，这个时候，客户端需要等待两个 `MSL`(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 `ACK `成功到达，挥手结束。否则客户端重发 ACK。

![16da9fd28b49f652](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/16da9fd28b49f652.png)

**为什么要等待 2 MSL?**

参考：[为什么TCP4次挥手时等待为2MSL？](https://www.zhihu.com/question/67013338)

当客户端发送ACK=1的报文后，客户端不知道服务端是否真的接收到自己的ACK，所以对于客户端来说：

（1）如果服务端没有收到自己的ACK，服务端自己会超时重传FiN

那么客户端再次接到重传的FIN，会再次发送ACK

（2）如果服务端收到了自己的ACK，也不会再发任何消息，包括ACK

无论是(1)还是(2)，客户端都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：

去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

这恰恰就是**2MSL( Maximum Segment Life)。**

**为什么是四次挥手而不是三次？**

- 因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。
- 因此先发一个ACK表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。 `如果是三次挥手会有什么问题？` 等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。






#### TCP流量控制
### UDP


## 应用层（HTTP,HTTPS,DNS）
### HTTP
#### HTTP

推荐阅读：[http](https://github.com/semlinker/awesome-http#http-%E9%9D%A2%E8%AF%95)

##### 简述HTTP协议

HTTP 是一个在**客户端和服务器之间传输**文字、图片、音频、视频等超文本数据的**约定和规范**。

默认使用 80 端口，它使用 **TCP** 作为传输层协议，保证了数据传输的可靠性。

##### HTTP的特点，他的缺点

**特点：**

1. 简单快速。客户端请求服务时，只需传送方法和路径。由于 HTTP 协议简单，因此通信快。
2. 灵活。可以传送任意类型的数据
3. 无连接。每完成一次请求即断开连接。
4. 无状态。HTTP 请求不会保留之前请求的信息，每次请求都是独立的。

**缺点：**

- **通信使用明文（不加密），内容可能会被窃听**

- 不验证通信方的身份，因此有可能遭遇伪装；

- 无法证明报文的完整性，有可能已遭篡改；

  参考：[面试常问的http的缺点](https://juejin.cn/post/6844903744593723400#heading-0)





##### 简述HTTP请求报文

HTTP 请求报文由**请求行**、**请求头**、**空行** 和 **请求体(请求数据)** 4 个部分组成，如下图所示：

![http-resource-3](https://i.loli.net/2021/01/13/NoAiDvRGH3uCBcs.png)



请求行 = 请求方法+ URL+ HTTP 协议版本，它们之间用空格分开。

请求头 由 多个键值对 组成，一行一个键值对

空行：跟在最后一个请求头后面，发送回车符和换行符，通知服务器以下不再有请求头。

请求体：存放请求数据，在GET请求中不能使用





HTTP响应报文由**状态行、响应头、空行和响应体**4 个部分组成，如下图所示：

![http-resource-4](https://i.loli.net/2021/01/13/8M36XnCizEfATGs.png)



参考：

 [HTTP 请求报文](https://github.com/semlinker/awesome-http#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)

[HTTP 响应报文](https://github.com/semlinker/awesome-http#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)





##### 简述HTTP请求的方法字段，get和post的区别

http/1.0规定了三种请求方法：GET、POST、HEAD

http/1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE、CONNECT

- **GET**：常用于获取数据，请求获取Request-URI所标识的资源
- **POST**：提交数据，在Request-URI所标识的资源后附加新的数据
- **PUT**：修改数据，请求服务器存储一个资源，并用Request-URI作为其标识
- **DELETE**：请求服务器删除对应所标识的资源，但注意：客户端无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求
- **HEAD**：与GET类似（获取资源的元信息），但只请求获取有Request-URI所标识的资源的响应消息报头
- **OPTIONS**：列出可对资源实行的请求方式，用来跨域请求，成功后会在HTTP响应头中包含一个名为“Allow”的头，其值就是当前支持的请求方式
- **TRACE**：请求服务器回送收到的请求信息，主要用于测试或诊断。服务端在相应主体中携带它收到的原始请求报文的最终模样，客户端可以查看HTTP请求报文在发送过程中是否被修改
- **CONNECT**：建立连接隧道，用于代理服务器

**get和post的区别**

1. 从参数角度来看，GET参数通过URL传递，POST参数放在Request Body中

   浏览器通常限制URL长度在2k字节，大多数服务器最多处理64k字节的URL

   GET请求参数会被完整保留在浏览器的历史纪录中，POST不会

2. 从缓存角度来看，GET请求后浏览器会主动缓存，POST则不会，需要手动设置

3. 从编码角度来看，GET只能进行URL编码，只能接收ASCII字符，而POST支持更多的编码类型且不对数据类型限值

4. 从TCP角度来看，GET产生一个TCP数据包，浏览器会把http header和data一并发送，服务器响应200 OK并返回数据；POST产生两个TCP数据包，浏览器先发送http header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK并返回数据（火狐只发送一次）

5. 从幂等性的角度来看，GET是幂等的，而POST不是（幂等：[幂等](https://developer.mozilla.org/zh-CN/docs/Glossary/%E5%B9%82%E7%AD%89)）

> - get: 缓存、请求长度受限、会被历史保存记录
>   - 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景
> - post: 安全、大数据、更多编码类型
>
> 两者详细对比如下图:
>
> ![image-20210115103208482](https://i.loli.net/2021/01/15/LF8KVnfReUM3jHm.png)





**PUT和POST区别**

  PUT和POST方法作用类似，不同在于PUT是幂等的。当多次发送相同的POST请求，服务器上的资源数目可能会增加；而PUT请求后服务器上的资源数目不会增加，每次PUT都会覆盖前一次PUT的资源

##### HTTP状态码

状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：

- 1xx：指示信息 – 表示请求已接收，继续处理
- 2xx：成功 – 表示请求已被成功接收
- 3xx：重定向 – 要完成请求必须进行更进一步的操作
- 4xx：客户端错误 – 请求有语法错误或请求无法实现
- 5xx：服务器错误 – 服务器未能实现合法的请求

常见状态代码、状态描述的说明如下：

- 200 OK：客户端请求成功
- 204 No Content：没有新文档，浏览器应该继续显示原来的文档
- 206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它
- 301 Moved Permanently：永久重定向
- 302 Found：所请求的页面已经临时转移至新的url
- **304 Not Modified：协商缓存命中**
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden：对被请求页面的访问被禁止
- 404 Not Found：请求资源不存在
- 500 Internal Server Error：服务器发生不可预期的错误
- 503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常

#### HTTP2.0

> HTTP/2的新特性:二进制协议、 多路复用、数据流、 头信息压缩、服务器推送

**二进制协议** HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

**多路复用** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。

**数据流** HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。

**头信息压缩** HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。

**服务器推送** HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。



详细的可以看下[HTTP----HTTP2.0新特性](https://juejin.cn/post/6844903545532071943#heading-8)



#### 如何解决HTTP队头阻塞的问题

http2.0多路复用，实现一个连接里可以发送和接受多个请求，且不用按照顺序一个一个发送





### HTTPS







#### 相比于HTTP有什么区别？

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

  参考：[HTTP 与 HTTPS 的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

  

#### 相比于HTTP有什么优势？优势如何实现的？

https更安全。因为HTTPS = HTTP + 加密 + 证书 + 完整性保护。而相关安全操作是通过 SSL 协议来进行实现的。

[[秃破前端面试] —— HTTP && HTTPS](https://juejin.cn/post/6844904029416341512#heading-6)

混合加密：保证效率和安全

数字签证



##### 混合加密机制

混合加密机制。也就是对称加密与非对称加密混用来实现加密机制。

###### 数据传输阶段 —— 对称密钥加密

对称密钥加密又称为共享密钥加密（Common key crypto system），是在加密和解密阶段使用同一个密钥的方式。这也就意味着通信双方必须都存储一份相同的密钥，但是这也就意味着，只要攻击者获取到密钥，那么一样可以进行攻击。

![image-20210115100302661](https://i.loli.net/2021/01/15/lO2yq4R3WPcKEas.png)




因此，加密的重中之重就是**如何能安全的发送密钥不被窃取？**证书交验证阶段 —— 非对称密钥加密

###### 证书交验证阶段 —— 非对称密钥加密

公开密钥加密（Public-key cryptography）解决了上述的发送密钥问题。它采用一对儿非对称的密钥，一把是私有密钥（private key），一把是公开密钥（public key）。加密过程就是，发送加密报文的一方使用对方的公开密钥进行加密，接收方使用自己本地的私有密钥进行解密，也就是说发送方并不需要附带着发送用来解密的密钥，这种方式就不需要考虑密钥在传输过程中被攻击者获取到。

私有密钥与公开密钥的关系是一对多的关系，公开密钥可以发送转交给任何人，而只要采用公开密钥加密的报文，都只能使用本地唯一的私有密钥进行解密。

###### 混合加密机制

上面说了，HTTPS 采用的是混合加密，那么既然非对称的公开密钥方式更好，为啥不只采一种呢？

原因是，非对称的公开加密相比对称的共享密钥加密处理起来更为复杂，效率更低，在前端业务交互中，一般来说都是存在大量的 HTTP 请求的，所以非对称加密的效率是无法被接受的。此外非对称加密的场景只在服务端保存私钥，也就是说一对公私钥只能是单向传输数据，用来确认通信安全以及服务端返回证书。确认安全之后，传输数据采用的就是速度更快的共享密钥。

![image-20210115100204355](https://i.loli.net/2021/01/15/JZbN8W6ulgEDkjM.png)






##### 数字签名，数字证书流程

上面的过程也存在一个问题，安全的本质是使用密钥来进行数据加密解密。那么如果最本质的密钥都是有问题的，那么安全性就无从谈起，因此，这个密钥必须是通信双方，也就是客户端和服务端都认证通过的才行。这个工作既不能客户端去做，也不能服务端去做，一般来说是交给第三方权威机构 —— 数字证书认证机构（CA，Certificate Authority）。



![image-20210115100234100](https://i.loli.net/2021/01/15/e78d53TfjVPlU1z.png)



##### TLS握手
##### RSA握手

##### DNS



#### HTTPS全是优点吗？

- 速度会慢 2～100 倍

HTTPS慢其实是慢在 SSL 协议通信商上，因为 SSL 协议要进行加密解密处理，会占用CPU和网络资源，总体上会慢一些。

- CA证书一般来说不免费

其次就是，申请 CA 证书是需要花钱的，当然，现在很多手段可以申请到免费的 HTTPS 证书，但是大部分权威的还是收费的。所以大部分小型个人开发者，使用的应该都是HTTP协议。

#### 简述DNS协议



#### DNS为什么选用UDP协议作为传输层协议




## 面试常见考题
### POST和GET区别



### TLS/SSL中为什么一定要用三个随机数，来生成“会话密钥”
### SSL连接 断开后如何恢复
### RSA算法的安全性保障
### DNS为什么用UDP协议作为传输层协议
### 当你在浏览器中输入google.com并且按下回车后发生了什么？

1.DNS解析，将域名解析成IP地址

2.TCP：TCP三次握手

3.发送HTTP请求

4.服务器处理请求并且返回HTTP报文

5.浏览器解析html并渲染页面

6.断开连接

### 谈谈CDN服务
### 什么是正向代理和反向代理
### 负载平衡的两种实现方式
### http请求方式options有什么用
### http1.1和http1.0有什么区别
### 网站域名家www和不加www的区别
### 即使通讯的实现，短轮询，长轮询，SSE和web Socket间的区别
### 怎么实现多个网站之间共享登录状态
