## 三. TCP三次握手

#### 前置知识

TCP 报文常用：

seq 序号：占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记

ack 序号（确认序号）：占 32 位，只有 ACK 标志位是 1 时，确认序号才有效，ack = seq + 1

标识位：

- SYN: 发起一个新连接
- ACK: 确认序号有效
- FIN: 释放一个连接



而对应SYN和ACK的分别是Sequence number(顺序号码) 和Acknowledge number(确认号码)

#### TCP三次握手流程


第一次握手：客户端发送位码syn=1，随机产生seq number=1234567。服务端由syn=1知道，客户端要求建立连接。

第二次握手：服务端在收到syn=1后知道客户端请求连接，所以向客户端发送ack=1和对应的ack number（第一次握手的seq number+1）；syn=1， 随机的seq number=(123456) 的包

第三次握手：客户端检查ack number是否正确（即第一次发送的seq number+1），ack是否为1。

​	若正确，客户端再次发送ack=1，ack number=（123456+1）。服务端收到后确认ack和ack number，正确则建立连接成功

参考文章：[TCP三次握手中SYN，ACK，Seq三者的关系](https://blog.csdn.net/u014507230/article/details/45310847)



##### **为什么是3次握手，不是2次握手？**

**2次握手只能确认客户端的发送功能和服务器的接收功能没有问题；但是不能保证客户端的接收功能和服务端的发送功能是否正常。**

>参考：[**TCP.md**](https://github.com/ChellyAI/note/blob/master/HTTP/3%E3%80%81TCP.md)
>
> 这是为了确认在即将建立连接时，两端都处于准备建立连接的状态，防止失效的连接请求报文被服务器接收而产生错误。**通过三次握手，能够让双方都知道彼此的接收能力、发送能力没问题**。
>
>  假设客户端发送请求连接报文A，因为网络原因超时，此时TCP启动超时重传机制，再次发送连接请求报文B，顺利到达服务端并建立连接。结束连接后，服务端又收到报文A，此时若不同客户端确认，直接进入**ESTABLISHED**状态并发送同意连接报文至客户端，而客户端已经处于**CLOSED**状态，因此连接不会建立且服务端一直处于等待状态，造成资源浪费。
>
>  举个例子，两个人发微信聊天，如果A对B说“听得到吗”，B回复A“听得到”，正常情况下这两次交流就可以确认并开始互发消息。但假如第一次A问“听得到吗”的时候在隧道内，导致消息并未及时发出去，而A就把微信关闭了，当B接收到A后回复一句“听得到”并做好准备聊天，导致空等。而如果A收到B的回复后再回一句“好的好的，咱开始吧”，让B知道A现在也准备好了，加一道保险，更加安全。

##### **为什么不是四次？**

因为三次已经足够确认双方的发送和接收的能力了，四次以及四次以上当然就没必要啦

##### **三次握手过程中可以携带数据吗？**

可以，但是只有第三次，此时的`established`状态相对安全并且够确认服务器的接收发送能力。

而不能在第一次握手携带数据是为了防止黑客在`syn`中放入大量数据造成服务器资源的消耗。



#### TCP四次挥手流程

1. 向服务端B发送连接释放请求 FIN，其中 `FIN=1，seq=u`，并进入 **FIN_WAIT_1** 状态

2. 服务端收到报文，检测到FIN=1后，告诉应用层释放TCP连接，然后发送ACK包。其中 `ACK=1，ack=u+1，seq=v`，并进入**CLOSE-WAIT**状态。

   此时表明客户端到服务端的连接已经释放，不再接收客户端的数据，但可以继续向客户端发送数据

3. 服务端发送完数据后，向客户端发送连接释放请求 FIN，其中 `FIN=1，ACK=1，ack=u+1，seq=w`，然后进入**LAST-ACK**状态。

   通过延迟确认的技术，（通常由时间限制，否则对方会认为需要重传）可以将2、3合并，延迟ACK包的发送

4. 客户端收到服务端的连接释放请求 FIN 后，向服务端发送确认应答 ACK，其中 `ACK=1，seq=u+1，ack=w+1`，随后进入**TIME-WAIT**状态。该状态会持续2MSL（最大报文生存时长，指报文在网络中生存的最长时间），若该时间内没有收到服务端的重发请求的话，进入**CLOSED**状态。服务端收到确认应答后进入**CLOSED**状态。

> 注意了，这个时候，客户端需要等待两个 `MSL`(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 `ACK `成功到达，挥手结束。否则客户端重发 ACK。

![16da9fd28b49f652](https://gitee.com/jiang-xiaoyu/picture-bed-10/raw/master/images/16da9fd28b49f652.png)

##### **为什么要等待 2 MSL?**

参考：[为什么TCP4次挥手时等待为2MSL？](https://www.zhihu.com/question/67013338)

两段报文最大生存时长其实就是：去向ACK的最长传输时间和服务器重发请求时来向FIN消息的最长传输时间

当客户端发送ACK=1的报文后，客户端不知道服务端是否真的接收到自己的ACK，所以对于客户端来说：

（1）如果服务端没有收到自己的ACK，服务端自己会超时重传FiN

那么客户端再次接到重传的FIN，会再次发送ACK

（2）如果服务端收到了自己的ACK，也不会再发任何消息，包括ACK

无论是(1)还是(2)，客户端都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：

去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

这恰恰就是**2MSL( Maximum Segment Life)。**

##### **为什么是四次挥手而不是三次？**

- 因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, **必须等到服务端所有的报文都发送完毕了**，才能发`FIN`。
- 因此先发一个ACK表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。 `如果是三次挥手会有什么问题？` 等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

##### 参考：

[面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-6)

